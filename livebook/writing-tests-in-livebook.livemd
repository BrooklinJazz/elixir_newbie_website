<!-- livebook:{"persist_outputs":true} -->

# Writing Tests In Livebook

## Overview

While creating the curriculum for an upcoming [Elixir developer bootcamp](https://twitter.com/BrooklinJMyers/status/1480614054360018951) I've started to use Livebook to deliver interactive instruction. It's incredibly useful, and allows me to write instruction in markdown and interactive examples or exercises to ensure that students understand core concepts.

[Livebook](https://github.com/livebook-dev/livebook) supports writing ExUnit tests. This empowers the students to recieve quick feedback on their answers. However, while creating these lessons, it wasn't immediately obvious to me how to connect student input with ExUnit tests.

There are 3 main types of student input to accept. Input as a variable, input as module function, and input as a Kino Input.
I'll cover how to handle all 3 and how to write effective tests that provide clear feedback to students. In addition, I'll share 
how to use :persistent_term to handle especially tricky student input.

## Writing Tests in Livebook

Check out the [Livebook Repository](https://github.com/livebook-dev/livebook#getting-started) If you are not already familiar with Livebook.
There you will find how to [run livebook locally](https://fly.io/launch/livebook) or [launch a cloud instance with Fly.io](https://fly.io/launch/livebook).

You can even run this blog post as a Livebook to interact with the exercises. Just press this button!
[TODO ADD LIVEBOOK BADGE]

Once you have an environment to run livebook with, you can use the following code snippet in any
Elixir cell to setup ExUnit tests.

```elixir
ExUnit.start(auto_run: false)

defmodule ExampleTest do
  use ExUnit.Case, async: false

  test "example test" do
    assert true
  end
end

ExUnit.run()
```

```output
.

Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 test, 0 failures

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 0, skipped: 0, total: 1}
```

## Student Input as a Variable

Elixir variables cannot be access outside a module. You'll see that the following code doesn't work because my_variable
is undefined inside of the ExampleModule example_function.

```elixir
my_variable = 4

defmodule ExampleModule do
  def example_function do
    my_variable
  end
end

ExampleModule.example_function()
```

```output
warning: variable "my_variable" does not exist and is being expanded to "my_variable()", please use parentheses to remove the ambiguity or change the variable name
  livebook/writing-tests-in-livebook.livemd#cell:5: ExampleModule.example_function/0

```

You can get around this via module attributes like so:

```elixir
my_variable = 4

defmodule ExampleModule do
  @my_variable my_variable
  def example_function do
    @my_variable
  end
end

ExampleModule.example_function()
```

```output
4
```

And here's that in an ExUnit test.

```elixir
ExUnit.start(auto_run: false)

defmodule ExampleTest do
  @my_variable my_variable
  use ExUnit.Case, async: false

  test "example_test_name" do
    assert @my_variable === 4
  end
end

ExUnit.run()
```

```output
.

Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 test, 0 failures

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 0, skipped: 0, total: 1}
```

## Student Input as a Kino Input

[Kino](https://hexdocs.pm/kino/Kino.html) creates client-driven interactive widgets in your livebook. 
I primarily use it to create text or number inputs in my livebook lessons.

You can install Kino by including the following in an Elixir cell in your livebook.
You should check to make sure you use the latest version as this example may be out of date.

```elixir
Mix.install([
  {:kino, "~> 0.4.1"}
])
```

```output
:ok
```

Once done, you can use Kino Inputs like so:

```elixir
example_input = Kino.Input.text("Input Label")
```

Then the student input can be read like so

```elixir
example_input = Kino.Input.read(example_input)
```

```output
"Test"
```

You can use the variable the same way that you did above via module attributes. There used to be a bug with this
but Jose Valim and Jonatan Klosko [resolved it](https://github.com/livebook-dev/kino/issues/72).

```elixir
defmodule ExampleModule do
  @example_input example_input
  def example_function do
    @example_input
  end
end

ExampleModule.example_function()
```

```output
"Test"
```

You can be more concise by simply reading the input in the module attribute. Here's that all together
in an ExUnit test.

```elixir
student_input = Kino.Input.number("Write the number 2")
```

```elixir
ExUnit.start(auto_run: false)

defmodule ExampleTest do
  @student_input Kino.Input.read(student_input)
  use ExUnit.Case, async: false

  test "example_test_name" do
    assert @student_input === 2
  end
end

ExUnit.run()
```

```output
.

Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 test, 0 failures

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 0, skipped: 0, total: 1}
```

## Student Input as a Module Function

Student input as a module function is fairly straightforward, because it doesn't deal 
with any of the scoping issues that a variable or kino input do.

For example, if you gave the student an exercise to create a module that returns the first element in a list,
they could write their answer like so:

```elixir
defmodule StudentInput do
  def answer(list) do
    List.first(list)
  end
end
```

```output
{:module, StudentInput, <<70, 79, 82, 49, 0, 0, 5, ...>>, {:answer, 1}}
```

And then you can validate their solution with ExUnit.

```elixir
ExUnit.start(auto_run: false)

defmodule ExampleTest do
  use ExUnit.Case, async: false

  test "empty list" do
    assert StudentInput.answer([]) === nil
  end

  test "one element in list" do
    assert StudentInput.answer([1]) === 1
  end

  test "two elements in list" do
    assert StudentInput.answer([1, 2]) === 1
  end
end

ExUnit.run()
```

```output
...

Finished in 0.00 seconds (0.00s async, 0.00s sync)
3 tests, 0 failures

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 0, skipped: 0, total: 3}
```

## Persistent Term Hack

You may run into types of input that do not allow you to inject them into the tests via module
attributes.

For example, you can not inject a function via module attributes.

```elixir
ExUnit.start(auto_run: false)

example_fn = fn list -> List.first(list) end

defmodule ExampleTest do
  @example_fn example_fn
  use ExUnit.Case, async: false

  test "example_test_name" do
    assert @example_fn.([1]) === 1
  end
end

ExUnit.run()
```

You cannot use `def` either because you cannot invoke `def` outside of a module.

```elixir
ExUnit.start(auto_run: false)

def my_fn(list) do
  List.first(list)
end

defmodule ExampleTest do
  @my_fn my_fn
  use ExUnit.Case, async: false

  test "example_test_name" do
    assert @my_fn.([1]) === 1
  end
end

ExUnit.run()
```

For cases like this, I've created a hack using persistent term that allows you to effectively handle these scenarios.

The student would create their function like so.

```elixir
example_fn = fn list -> List.first(list) end
```

```output
#Function<44.40011524/1 in :erl_eval.expr/5>
```

Then you can store the input with the erlang :persistant_term library, and retrieve it
in the tests.

```elixir
ExUnit.start(auto_run: false)

:persistent_term.put("example_fn", example_fn)

defmodule ExampleTest do
  @example_fn example_fn
  use ExUnit.Case, async: false

  test "example_test_name" do
    example_fn = :persistent_term.get("example_fn")
    assert example_fn.([1]) === 1
  end
end

ExUnit.run()
```

```output
warning: module attribute @example_fn was set but never used
  livebook/writing-tests-in-livebook.livemd#cell:8

.

Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 test, 0 failures

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 0, skipped: 0, total: 1}
```

```output

18:43:44.780 [error] ** (UndefinedFunctionError) function Code.Fragment.cursor_context/1 is undefined (module Code.Fragment is not available)
    Code.Fragment.cursor_context("T")
    lib/livebook/intellisense/identifier_matcher.ex:50: Livebook.Intellisense.IdentifierMatcher.completion_identifiers/3
    lib/livebook/intellisense.ex:114: Livebook.Intellisense.get_completion_items/3
    lib/livebook/intellisense.ex:30: Livebook.Intellisense.handle_request/3
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:43:44.889 [error] ** (UndefinedFunctionError) function Code.Fragment.cursor_context/1 is undefined (module Code.Fragment is not available)
    Code.Fragment.cursor_context("To")
    lib/livebook/intellisense/identifier_matcher.ex:50: Livebook.Intellisense.IdentifierMatcher.completion_identifiers/3
    lib/livebook/intellisense.ex:114: Livebook.Intellisense.get_completion_items/3
    lib/livebook/intellisense.ex:30: Livebook.Intellisense.handle_request/3
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:43:46.075 [error] ** (UndefinedFunctionError) function Code.Fragment.cursor_context/1 is undefined (module Code.Fragment is not available)
    Code.Fragment.cursor_context("To i")
    lib/livebook/intellisense/identifier_matcher.ex:50: Livebook.Intellisense.IdentifierMatcher.completion_identifiers/3
    lib/livebook/intellisense.ex:114: Livebook.Intellisense.get_completion_items/3
    lib/livebook/intellisense.ex:30: Livebook.Intellisense.handle_request/3
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:43:46.198 [error] ** (UndefinedFunctionError) function Code.Fragment.cursor_context/1 is undefined (module Code.Fragment is not available)
    Code.Fragment.cursor_context("To im")
    lib/livebook/intellisense/identifier_matcher.ex:50: Livebook.Intellisense.IdentifierMatcher.completion_identifiers/3
    lib/livebook/intellisense.ex:114: Livebook.Intellisense.get_completion_items/3
    lib/livebook/intellisense.ex:30: Livebook.Intellisense.handle_request/3
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:43:46.524 [error] ** (UndefinedFunctionError) function Code.Fragment.cursor_context/1 is undefined (module Code.Fragment is not available)
    Code.Fragment.cursor_context("To imr")
    lib/livebook/intellisense/identifier_matcher.ex:50: Livebook.Intellisense.IdentifierMatcher.completion_identifiers/3
    lib/livebook/intellisense.ex:114: Livebook.Intellisense.get_completion_items/3
    lib/livebook/intellisense.ex:30: Livebook.Intellisense.handle_request/3
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:44:29.045 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("  test \"example_test_name\" do", {1, 22})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:44:29.879 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("  test \"example_test_name\" do", {1, 18})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:44:30.080 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("  test \"example_test_name\" do", {1, 17})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:44:40.122 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("  test \"example_test_name\" do", {1, 14})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:44:45.841 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("  test \"example_test_name\" do", {1, 29})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


```

## Improved Test Feedback

To improve feedback in tests, you may wish to create custom error messages or hints.
You can do that by passing a value into the second argument of the assert function from ExUnit.

```elixir
student_input = 2
```

```output
2
```

```elixir
ExUnit.start(auto_run: false)

defmodule ExampleTest do
  @student_input student_input
  use ExUnit.Case, async: false

  test "example_test_name" do
    assert @student_input <= 0,
           "Hint, make sure to enter a negative number. You entered: #{@student_input}"
  end
end

ExUnit.run()
```

```output


  1) test example_test_name (ExampleTest)
     livebook/writing-tests-in-livebook.livemd#cell:8
     Hint, make sure to enter a negative number. You entered: 2
     stacktrace:
       livebook/writing-tests-in-livebook.livemd#cell:9: (test)



Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 test, 1 failure

Randomized with seed 536299
```

```output
%{excluded: 0, failures: 1, skipped: 0, total: 1}
```

```output

18:51:18.963 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("    assert @student_input <= 0, \"Hint, make sure to enter a negative number. You entered: \#{@student_input}\"", {1, 48})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:51:19.867 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("    assert @student_input <= 0, \"Hint, make sure to enter a negative number. You entered: \#{@student_input}\"", {1, 19})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:51:20.263 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("    assert @student_input <= 0, \"Hint, make sure to enter a negative number. You entered: \#{@student_input}\"", {1, 20})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


18:51:22.512 [error] ** (UndefinedFunctionError) function Code.Fragment.surround_context/2 is undefined (module Code.Fragment is not available)
    Code.Fragment.surround_context("    assert @student_input <= 0, \"Hint, make sure to enter a negative number. You entered: \#{@student_input}\"", {1, 33})
    lib/livebook/intellisense/identifier_matcher.ex:68: Livebook.Intellisense.IdentifierMatcher.locate_identifier/4
    lib/livebook/intellisense.ex:325: Livebook.Intellisense.get_details/4
    lib/livebook/evaluator.ex:270: Livebook.Evaluator.handle_cast/2
    lib/livebook/evaluator.ex:212: Livebook.Evaluator.loop/1
    (stdlib 3.15.1) proc_lib.erl:226: :proc_lib.init_p_do_apply/3


```
